## Issue #72 - Precommit hooks with Husky and Prettier
- Configured Prettier, Husky, and lint-staged for automatic code formatting and validation
- Implementation details:
  - Created .prettierrc configuration (2 spaces, semicolons, standard settings)
  - Created .prettierignore to exclude build outputs and dependencies
  - Created .lintstagedrc to run prettier, typecheck, and tests on staged files
  - Added prettier, husky, and lint-staged to devDependencies in package.json
  - Added npm scripts: format, format:check, and prepare (for husky)
  - Created .husky/pre-commit hook to run lint-staged
  - Made pre-commit hook executable
- Pre-commit hook behavior:
  - Automatically formats all staged files with Prettier
  - Runs TypeScript type checking on staged files
  - Runs tests on staged files
  - Provides immediate feedback to LLMs and developers
- Key decisions:
  - Used standard Prettier configuration for consistency
  - Configured lint-staged to run both typecheck and tests for maximum safety
  - No CI workflow exists yet, so format:check not added to CI
  - User must run `pnpm install` to complete setup (permission issue prevents automated install)
- Files changed:
  - .prettierrc (new file)
  - .prettierignore (new file)
  - .lintstagedrc (new file)
  - .husky/pre-commit (new file)
  - package.json (added scripts and devDependencies)
  - SETUP_PRECOMMIT.md (new file with setup instructions)
- Blockers:
  - User needs to resolve pnpm permission issue and run `pnpm install`
  - User should run `npm run format` to format entire codebase before first commit



## Issue #74 - Video Editor Context Refactor with use-context-selector
- Implemented use-context-selector to eliminate prop drilling and improve performance
- Implementation details:
  - Updated video-editor-context.tsx to use createContext from use-context-selector
  - Expanded VideoEditorContextType to include all state, computed values, and callbacks
  - Built and memoized contextValue in VideoEditor with all necessary state
  - Refactored VideoPlayerPanel to have zero props, uses only useContextSelector
  - Refactored ClipTimeline to have zero props, uses only useContextSelector
  - Refactored ClipItem to compute isSelected/isCurrentClip via selectors, keeps minimal props (clip, isFirstItem, isLastItem, timecode, nextLevenshtein, callback props)
  - Refactored ClipSectionItem to use selectors for dispatch and state, keeps minimal props (section, isFirstItem, isLastItem, callback props)
- Key decisions:
  - Modal state (isExportModalOpen, isAddVideoModalOpen) stays as local useState but passes through context
  - Section management callbacks (onEditSection, onAddSectionBefore, onAddSectionAfter) added to context
  - ClipItem and ClipSectionItem keep some props for callbacks that are created inline in parent component
  - Conservative approach: minimal component restructuring, no Container/Presentation split
- Files changed:
  - app/features/video-editor/video-editor-context.tsx (expanded context type, switched to use-context-selector)
  - app/features/video-editor/video-editor.tsx (built memoized contextValue, removed prop passing)
  - app/features/video-editor/components/video-player-panel.tsx (zero props, uses selectors)
  - app/features/video-editor/components/clip-timeline.tsx (zero props, uses selectors)
  - app/features/video-editor/components/clip-item.tsx (reduced props, uses selectors for state)
  - app/features/video-editor/components/clip-section-item.tsx (reduced props, uses selectors for state)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Monitor re-render performance with React DevTools Profiler to verify improvements
  - Consider further optimizations if needed


## Issue #73 - Error Page Copy to Clipboard
- Added copy-to-clipboard functionality to error boundary
- Implementation details:
  - Added useState hook for isCopied state tracking
  - Imported CopyIcon and CheckIcon from lucide-react
  - Created copyErrorToClipboard function using navigator.clipboard.writeText()
  - Added "Copy error" button with visual feedback (shows "Copied" with check icon for 2 seconds)
  - Error details include: status code, title, description, and stack trace (if available)
- Key decisions:
  - Followed existing clipboard pattern from use-clipboard-operations.ts
  - Placed copy button first in footer for easy access
  - Uses 2-second timeout for copy confirmation (consistent with existing patterns)
  - Only includes stack trace in copied text if it's available (dev mode)
- Files changed:
  - app/root.tsx (added copy functionality to ErrorBoundary component)
- Testing:
  - All tests pass
  - TypeScript type checking passes


## Issue #75 - Standalone Video File Tree
### Task 1: Add STANDALONE_VIDEO_FILES_DIR environment variable and file system structure
- Added environment variable for configuring standalone video files storage location
- Implementation details:
  - Created app/services/standalone-video-files.ts with utility functions
  - getStandaloneVideoFilesBaseDir(): gets base directory from env var (defaults to ./standalone-video-files)
  - getStandaloneVideoFilePath(videoId, filename?): constructs full path to files
  - File organization structure: {BASE_DIR}/{videoId}/{filename}
- Key decisions:
  - Used services directory for utility functions (consistent with existing patterns)
  - Provided sensible default if environment variable not set
  - Files organized by video ID to prevent conflicts
- Files changed:
  - .env (added STANDALONE_VIDEO_FILES_DIR variable)
  - .env.example (created with documentation for all env vars)
  - app/services/standalone-video-files.ts (new utility module)
- Testing:
  - All tests pass
  - TypeScript type checking passes

### Task 2: Implement API routes for file CRUD operations
- Created three API route files for standalone video file operations
- Implementation details:
  - api.standalone-files.create.ts: creates new files with content validation
  - api.standalone-files.update.ts: updates existing file content
  - api.standalone-files.delete.ts: deletes files from filesystem
  - All routes use Effect FileSystem API and Schema validation
  - Routes validate video exists and is standalone (lessonId === null)
  - Directory automatically created when first file is added
- Key decisions:
  - Separate route per operation (following codebase patterns)
  - Validation: 409 Conflict if file already exists on create
  - Validation: 404 Not Found if file doesn't exist on update/delete
  - Validation: 400 Bad Request if video is lesson-connected
  - Uses withDatabaseDump for state persistence
  - Comprehensive error handling with specific status codes
- Files changed:
  - app/routes/api.standalone-files.create.ts (new file)
  - app/routes/api.standalone-files.update.ts (new file)
  - app/routes/api.standalone-files.delete.ts (new file)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Task 3: Create loader to fetch files for standalone video write page

### Task 3: Create loader to fetch files for standalone video write page
- Modified loader in videos.$videoId.write.tsx to fetch standalone video files
- Implementation details:
  - Imports getStandaloneVideoFilePath utility
  - For standalone videos, checks if directory exists
  - If directory exists, reads all files and returns metadata
  - Files returned with same structure as lesson-connected videos (path, size, defaultEnabled)
  - defaultEnabled based on file extension matching DEFAULT_CHECKED_EXTENSIONS
  - Only includes actual files, not directories
- Key decisions:
  - Gracefully handles missing directory (returns empty files array)
  - Uses Effect FileSystem API consistent with rest of codebase
  - Follows same pattern as lesson-connected video file loading
  - File tree will automatically show standalone files in UI (no UI changes needed)
- Files changed:
  - app/routes/videos.$videoId.write.tsx (modified loader)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Task 4: Create UI component for managing standalone video files (modal, file tree interactions)

### Task 4: Create UI component for managing standalone video files
- Created complete file management UI for standalone videos
- Implementation details:
  - Created StandaloneFileManagementModal component (handles create/edit modes)
    - Single modal with mode prop ("create" or "edit")
    - Filename input (disabled in edit mode)
    - Content textarea (monospace font for code)
    - Form submission via useFetcher to create/update API routes
    - Auto-revalidates after submission to refresh file list
  - Created StandaloneFileTree component (simple flat list)
    - Displays files with filename and size
    - Edit button (opens modal with file content)
    - Delete button (opens confirmation dialog)
    - Hover effects to show/hide buttons
    - Empty state message when no files
  - Created DeleteStandaloneFileModal component
    - Confirmation dialog with destructive styling
    - Shows filename being deleted
    - Form submission via useFetcher to delete API route
  - Created api.standalone-files.read.ts route
    - Loader that reads file content from filesystem
    - Query params: videoId, filename
    - Returns plain text response
    - Validates video exists and is standalone
  - Modified videos.$videoId.write.tsx to integrate components
    - Added state for modal management (isFileModalOpen, fileModalMode, etc.)
    - Added handleAddFile, handleEditFile, handleDeleteFile handlers
    - Added "Add File" button above file tree for standalone videos
    - Renders StandaloneFileTree instead of FileTree for standalone videos
    - Renders both modals at bottom of component
    - Uses useRevalidator to refresh file list after operations
- Key decisions:
  - File tree only appears for standalone videos (isStandalone === true)
  - Files displayed in flat list (no directory nesting for MVP)
  - Edit fetches file content on-demand (not pre-loaded in loader)
  - Modal closes automatically after successful submission
  - Revalidation triggered after modal close to update file list
  - Monospace font in textarea for better code editing experience
  - Filename field disabled in edit mode (no rename support in MVP)
- Files changed:
  - app/components/standalone-file-management-modal.tsx (new component)
  - app/components/StandaloneFileTree.tsx (new component)
  - app/components/delete-standalone-file-modal.tsx (new component)
  - app/routes/api.standalone-files.read.ts (new API route)
  - app/routes/videos.$videoId.write.tsx (integrated all components)
- Testing:
  - All tests pass
  - TypeScript type checking passes
  - Code formatting passes
- Next steps:
  - Task 4 is complete
  - Issue #75 is complete - all user stories implemented


## Issue #76 - Add/Remove Standalone Video Files to Context
### Task 1: Add checkbox functionality to standalone files
- Added checkbox UI to StandaloneFileTree component (similar to FileTree)
- Implementation details:
  - Updated StandaloneFileTree to accept enabledFiles and onEnabledFilesChange props
  - Added Checkbox component import and usage
  - Added handleToggle function to manage selection state
  - Each file row now shows checkbox before filename
  - Checkbox state synced with enabledFiles Set
- Added "Select All" and "Deselect All" buttons above file tree
  - Buttons only visible when files exist
  - "Select All" adds all file paths to enabledFiles
  - "Deselect All" clears all selections
- Updated videos.$videoId.write.tsx to wire up state
  - Passed enabledFiles and onEnabledFilesChange to StandaloneFileTree
  - enabledFiles state now properly initialized from defaultEnabled
- Updated acquireTextWritingContext to load standalone video files
  - Added import for getStandaloneVideoFilePath
  - Added else branch to handle standalone videos (no lesson)
  - Loads files from standalone video directory
  - Filters files based on enabledFiles parameter
  - Handles both text and image files (same as lesson files)
  - Files properly included in AI context when selected
- Key decisions:
  - Followed exact same pattern as FileTree component for consistency
  - Checkbox appears before filename (same as lesson files)
  - Select All/Deselect All buttons match UI style of "Add File" button
  - Standalone files now fully integrated into context system
- Files changed:
  - app/components/StandaloneFileTree.tsx (added checkbox functionality)
  - app/routes/videos.$videoId.write.tsx (added Select All/Deselect All buttons, wired up enabledFiles)
  - app/services/text-writing-agent.ts (added standalone file loading logic)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Task 1 is complete
  - Issue #76 is complete - standalone files now have same context functionality as lesson files


## Issue #76 (continued) - Add Select All/Deselect All buttons to lesson video files
- Added Select All and Deselect All buttons to lesson video file tree (matching standalone files)
- Implementation details:
  - Wrapped lesson video FileTree component in a container div with space-y-2
  - Added "Files" header (matching standalone files UI)
  - Added Select All button that adds all file paths to enabledFiles Set
  - Added Deselect All button that clears all selections
  - Buttons only visible when files.length > 0
  - Buttons use same styling as standalone file buttons (variant="ghost", size="sm", h-7, text-xs)
- Key decisions:
  - Kept exact same button styling and positioning as standalone files for consistency
  - Both lesson videos and standalone videos now have identical Select All/Deselect All treatment
- Files changed:
  - app/routes/videos.$videoId.write.tsx (added Select All/Deselect All buttons to lesson video section)
- Testing:
  - All tests pass
  - TypeScript type checking passes


## Issue #77 - Replace Select All/Deselect All buttons with checkbox
- Replaced Select All and Deselect All buttons with a single checkbox for both lesson and standalone video files
- Implementation details:
  - Replaced button group with checkbox that matches transcript checkbox behavior
  - Checkbox shows checked when all files are selected
  - Checkbox shows indeterminate when some (but not all) files are selected
  - Checkbox shows unchecked when no files are selected
  - Clicking checkbox when checked/indeterminate deselects all files
  - Clicking checkbox when unchecked selects all files
  - For standalone videos, "Add File" button moved to same row as checkbox
- Key decisions:
  - Followed exact same pattern as transcript checkbox for consistency
  - Three-state checkbox (checked/indeterminate/unchecked) provides clear visual feedback
  - Layout matches transcript section with checkbox and label
- Files changed:
  - app/routes/videos.$videoId.write.tsx (replaced buttons with checkbox for both lesson and standalone files)
- Testing:
  - All tests pass
  - TypeScript type checking passes


## Issue #78 - Upload non-text files to standalone files modal
- Implemented file upload support for binary files (images, PDFs, etc.)
- Implementation details:
  - Updated StandaloneFileManagementModal component:
    - Create mode: shows file input with auto-filename population
    - Edit mode: keeps textarea (text files only can be edited)
    - Added file size display and filename override option
    - Changed button text from "Create File" to "Upload File"
    - Added encType="multipart/form-data" to form
  - Updated api.standalone-files.create.ts:
    - Handles FormData with File objects
    - Supports both file uploads (binary) and text content (for backwards compatibility)
    - Writes all files as binary data using fs.writeFile
    - Allows filename override via optional filename field
  - Updated api.standalone-files.update.ts:
    - Only supports text content updates (binary files must be re-uploaded)
    - Writes text as binary using TextEncoder for consistent handling
    - Clear error message if non-text content provided
  - Updated api.standalone-files.read.ts:
    - Reads all files as binary using fs.readFile
    - Detects MIME type from file extension
    - Serves files with proper Content-Type headers
    - Supports images, PDFs, documents, text, code, and archives
    - Converts Uint8Array to Buffer for Response compatibility
- Key decisions:
  - Create mode supports any file type via upload
  - Edit mode only supports text files (binary files cannot be edited in UI)
  - All files stored as binary for consistency
  - MIME type detection based on extension (simple but effective)
  - File system already supported binary files - only UI/API needed changes
- Files changed:
  - app/components/standalone-file-management-modal.tsx (added file upload UI)
  - app/routes/api.standalone-files.create.ts (binary file upload support)
  - app/routes/api.standalone-files.update.ts (text-only updates with binary write)
  - app/routes/api.standalone-files.read.ts (binary file serving with MIME types)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Issue #78 is complete - users can now upload images, PDFs, and other binary files


## Issue #79 - Add text vs file upload options
- Converted "Add File" button to dropdown menu with two options
- Implementation details:
  - Modified videos.$videoId.write.tsx to replace button with DropdownMenu
  - Added two menu items: "Add from Text" and "Add from File"
  - Added fileUploadMode state to track which mode is selected
  - Updated handleAddFile to accept mode parameter ("text" | "file")
  - Added uploadMode prop to StandaloneFileManagementModal
  - Updated modal to conditionally render file upload UI or text input UI
  - In text mode: shows filename input (enabled) and textarea for content
  - In file mode: shows file input and optional filename override
  - API route already supported both modes (text content and file uploads)
- Key decisions:
  - Used existing dropdown menu pattern from codebase (similar to README dropdown)
  - Kept FormData for both modes (API route handles both elegantly)
  - Text mode creates files with text content, file mode uploads files from disk
  - Edit mode continues to work as before (always uses text mode)
  - Filename input enabled in text create mode, disabled in edit mode
- Files changed:
  - app/routes/videos.$videoId.write.tsx (added dropdown menu, updated handlers)
  - app/components/standalone-file-management-modal.tsx (added uploadMode prop and conditional rendering)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Issue #79 is complete - users can now choose between pasting text or uploading files


## Issue #80 - Add "Add from Copy-Paste" option (Task 1 of 6)
### Task 1: Add "Add from Copy-Paste" option to dropdown menu
- Added third option to the Add File dropdown menu
- Implementation details:
  - Added ClipboardIcon to lucide-react imports
  - Added new DropdownMenuItem for "Add from Copy-Paste"
  - Updated handleAddFile function signature to accept "paste" mode
  - Currently maps to existing text modal (foundation for future enhancements)
- Key decisions:
  - Used ClipboardIcon for visual consistency with clipboard operations
  - "paste" mode maps to "text" uploadMode as a reasonable starting point
  - UI positioned between "Add from File" and "Add from Text" options
- Files changed:
  - app/routes/videos.$videoId.write.tsx (added ClipboardIcon import, new menu item, updated handler)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Task 2: Implement clipboard paste detection in modal
  - Task 3: Add content type detection (text vs image)
  - Task 4: Implement smart sequential filename generation
  - Task 5: Add image preview functionality
  - Task 6: Update create API to handle base64 image data

### Task 2 & 3: Implement clipboard paste detection and content type detection
- Created new StandaloneFilePasteModal component for dedicated paste workflow
- Implementation details:
  - Modal shows focusable paste area with visual prompt
  - onPaste handler captures clipboard events
  - Detects images from clipboard via DataTransferItemList
  - Falls back to plain text if no image found
  - Converts image blobs to base64 data URLs via FileReader
  - Stores pasted content in state with type discrimination ("text" | "image")
  - Shows preview of pasted content (text shown in pre, images show placeholder for now)
  - Auto-focuses paste area when modal opens
  - "Clear and paste again" button allows retry
  - Filename input required before submission
  - Form submission via useFetcher to /api/standalone-files/create
- Integrated into videos.$videoId.write.tsx:
  - Added isPasteModalOpen state
  - Modified handleAddFile to route "paste" mode to new modal
  - Added handlePasteModalClose with revalidation
  - Rendered StandaloneFilePasteModal alongside other modals
- Key decisions:
  - Separate modal component for paste workflow (cleaner than mode switching)
  - Paste area is focusable div with tabIndex={0} for accessibility
  - Type detection happens in order: images first, then text fallback
  - Base64 encoding for images (API integration pending)
  - Uses same form submission pattern as existing modals
  - Placeholders for text/image filenames (smart generation coming in next task)
- Files changed:
  - app/components/standalone-file-paste-modal.tsx (new component)
  - app/routes/videos.$videoId.write.tsx (integrated paste modal)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Task 4: Implement smart sequential filename generation
  - Task 5: Add image preview functionality
  - Task 6: Update create API to handle base64 image data

### Task 4: Implement smart sequential filename generation
- Implemented intelligent filename generation for pasted content
- Implementation details:
  - Added existingFiles prop to StandaloneFilePasteModal
  - Created generateFilename() function with type-specific logic
  - For text files: generates "notes.md" first, then "notes-1.md", "notes-2.md", etc.
  - For images: generates "diagram-1.png", "diagram-2.png", etc. (always numbered)
  - Auto-populates filename input when content is pasted
  - Filename is editable by user before submission
  - Sequential counter increments to find first available filename
- Key decisions:
  - Text files start with unnumbered "notes.md" for simplicity (first file)
  - Images always start at "diagram-1.png" (never unnumbered)
  - Follows exact naming pattern specified in issue #80
  - Auto-population via useEffect when pastedContent changes
  - User can still override the generated filename
- Files changed:
  - app/components/standalone-file-paste-modal.tsx (added generateFilename, auto-population logic)
  - app/routes/videos.$videoId.write.tsx (passed existingFiles prop to modal)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Task 5: Add image preview functionality
  - Task 6: Update create API to handle base64 image data

### Task 5: Add image preview functionality
- Implemented image preview in paste modal for pasted images
- Implementation details:
  - Replaced placeholder text "Image pasted (preview coming soon)" with actual <img> element
  - Image displays base64 data URL directly from pastedContent.data
  - Preview styling: max-h-96 (limits height), max-w-full (prevents overflow), object-contain (maintains aspect ratio), rounded (matches container)
  - Preview appears in same container as text preview, with consistent styling
- Key decisions:
  - Used max-h-96 to prevent oversized images from dominating the modal
  - object-contain ensures images display properly regardless of aspect ratio
  - No additional state needed - base64 data already available from paste handler
- Files changed:
  - app/components/standalone-file-paste-modal.tsx (replaced placeholder with img element)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Task 6: Update create API to handle base64 image data

### Task 6: Update create API to handle base64 image data
- Updated api.standalone-files.create.ts to handle base64 data URLs from paste modal
- Implementation details:
  - Added detection for base64 data URLs (starts with "data:")
  - Regex pattern to extract MIME type and base64 content from data URL
  - Uses atob() to decode base64 string to binary
  - Converts binary string to Uint8Array for filesystem write
  - Validates data URL format and returns 400 error if invalid
  - Falls back to plain text handling for non-data-URL content
- Key decisions:
  - Used native atob() for base64 decoding (available in Node.js 16+)
  - Byte-by-byte conversion to Uint8Array for proper binary handling
  - Kept existing text content path for backwards compatibility
  - Same validation and error handling patterns as existing code
- Files changed:
  - app/routes/api.standalone-files.create.ts (added base64 handling logic)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Task 6 is complete
  - Issue #80 is complete - full paste workflow working for both text and images


## Issue #81 - Remove "Add from Text" option
- Removed "Add from Text" and "Add from File" options from standalone video file management
- Implementation details:
  - Replaced dropdown menu with single "Add from Clipboard" button
  - Button directly opens StandaloneFilePasteModal (setIsPasteModalOpen)
  - Removed handleAddFile function (no longer needed)
  - Removed fileUploadMode and fileModalMode state variables
  - Simplified StandaloneFileManagementModal to edit-only mode
  - Modal now only supports text editing (no create or file upload modes)
  - Removed all conditional rendering for create/upload modes
  - Kept edit functionality for existing files via Edit button
  - Updated help text: "Binary files must be re-uploaded via clipboard"
- Key decisions:
  - Paste modal is now the only way to create new files (text or images)
  - Edit modal still needed for editing text content of existing files
  - Simplified component props and state management
  - Removed unused imports (then restored ones still needed elsewhere)
- Files changed:
  - app/routes/videos.$videoId.write.tsx (simplified button, removed dropdown, cleaned state)
  - app/components/standalone-file-management-modal.tsx (edit-only mode)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Issue #81 is complete - clipboard paste is now the only creation method


## Issue #82 - Add clipboard paste functionality to lesson videos
- Added clipboard paste functionality for lesson-connected videos
- Implementation details:
  - Created app/routes/api.lesson-files.create.ts API route
    - Validates video exists and is lesson-connected (lessonId !== null)
    - Constructs file path in lesson directory (repo/section/lesson)
    - Handles both text content and base64 image data (same as standalone)
    - Writes files to lesson directory using Effect FileSystem API
    - Returns 409 if file already exists
  - Created app/components/lesson-file-paste-modal.tsx component
    - Identical UI/UX to StandaloneFilePasteModal
    - Smart sequential filename generation (notes.md, notes-1.md, diagram-1.png, etc.)
    - Clipboard paste detection (text vs image)
    - Image preview for pasted images
    - Submits to /api/lesson-files/create endpoint
  - Updated app/routes/videos.$videoId.write.tsx
    - Added LessonFilePasteModal import
    - Added isLessonPasteModalOpen state
    - Added handleLessonPasteModalClose handler
    - Added "Add from Clipboard" button to lesson files section (matches standalone UI)
    - Renders LessonFilePasteModal for lesson-connected videos
- Key decisions:
  - No edit or delete functionality for lesson files (as specified in issue)
  - Files save directly to lesson directory (not a separate standalone directory)
  - Reuses same filename generation logic as standalone files
  - Revalidates after file creation to refresh file list
- Files changed:
  - app/routes/api.lesson-files.create.ts (new API route)
  - app/components/lesson-file-paste-modal.tsx (new component)
  - app/routes/videos.$videoId.write.tsx (integrated paste modal)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Issue #82 is complete - lesson videos now have clipboard paste functionality

## Issue #84 - File Preview Modal (Task 1 of 7)
### Task 1: Create FilePreviewModal component and integrate with file trees
- Implemented file preview modal for both lesson and standalone videos
- Implementation details:
  - Created FilePreviewModal component with text/image/binary support
  - Detects file type based on extension (text, image, or binary)
  - Text files: displays in monospace pre tag with word wrap
  - Images: displays with max size constraints and proper scaling
  - Binary files: shows "cannot be previewed" message
  - Created API route api.lesson-files.read.ts for reading lesson files
  - Reused existing api.standalone-files.read.ts for standalone files
  - Updated FileTree component to add onFileClick prop
  - File names now clickable buttons with hover underline
  - Updated StandaloneFileTree component to add onFileClick prop
  - Integrated modal into videos.$videoId.write.tsx with handlers
- Key decisions:
  - Single modal component works for both lesson and standalone videos
  - File type detection based on comprehensive extension list
  - Image URLs properly cleaned up to prevent memory leaks
  - Modal uses large width (sm:max-w-4xl) for comfortable viewing
  - Text files limited to 600px height with scrolling
  - Clickable file names styled as buttons for accessibility
- Files changed:
  - app/components/file-preview-modal.tsx (new component)
  - app/routes/api.lesson-files.read.ts (new API route)
  - app/components/FileTree.tsx (added onFileClick prop)
  - app/components/StandaloneFileTree.tsx (added onFileClick prop)
  - app/routes/videos.$videoId.write.tsx (integrated modal)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Task 1 is complete - users can now click file names to preview content


## Issue #83 - Newsletter Mode
- Added newsletter writing mode to the article writer
- Implementation details:
  - Added "newsletter" to Mode type in app/features/article-writer/types.ts
  - Added "newsletter" to TextWritingAgentMode type in app/services/text-writing-agent.ts
  - Created app/prompts/generate-newsletter.ts with newsletter-specific prompt
    - Friendly, informal style (but not stupid)
    - Short preview/teaser format (a few paragraphs at most)
    - Designed for AI Hero audience
    - Teases key insights without giving everything away
    - Supports images (especially diagrams)
    - Signs off with "Matt"
  - Added newsletter case to createTextWritingAgent switch statement
  - Added "newsletter" to modeToLabel mapping in UI
  - Added newsletter SelectItem with MailIcon and description to mode selector dropdown
- Key decisions:
  - Newsletter mode follows existing mode pattern (no architectural changes needed)
  - Reuses existing image instructions functionality
  - Focus on enticing readers to read the full article
  - Conversational and engaging tone per user requirements
- Files changed:
  - app/features/article-writer/types.ts (added newsletter to Mode type)
  - app/services/text-writing-agent.ts (added newsletter to TextWritingAgentMode, import, and switch case)
  - app/prompts/generate-newsletter.ts (new prompt file)
  - app/routes/videos.$videoId.write.tsx (added newsletter to modeToLabel, added MailIcon import, added SelectItem)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Issue #83 is complete - newsletter mode is now available in the mode selector


## Issue #85 - Fix newsletter mode 400 error
- Fixed "Invalid request" error when using newsletter mode in article writer
- Implementation details:
  - Added Schema.Literal("newsletter") to the mode union in chatSchema (videos.$videoId.completions.ts)
  - Newsletter mode was added in Issue #83 but schema validation was not updated
  - Schema validation was rejecting requests with mode="newsletter", causing 400 error
- Key decisions:
  - Simple one-line fix to add missing mode literal to schema
  - No other changes needed - newsletter prompt and agent logic already implemented correctly
- Files changed:
  - app/routes/videos.$videoId.completions.ts (added newsletter to mode schema)
- Testing:
  - All tests pass
  - TypeScript type checking passes
- Next steps:
  - Issue #85 is complete - newsletter mode now works without validation errors


## Issue #86 - Infer TextWritingAgentMode from schema definition
- Eliminated duplicate type definitions by inferring TextWritingAgentMode from the schema
- Implementation details:
  - Extracted modeSchema as a separate const in videos.$videoId.completions.ts
  - Created TextWritingAgentMode type using Schema.Schema.Type<typeof modeSchema>
  - Exported TextWritingAgentMode from videos.$videoId.completions.ts
  - Updated text-writing-agent.ts to import and use the inferred type
  - Updated article-writer types.ts to import and alias the inferred type as Mode
  - Schema now serves as single source of truth for mode types
- Key decisions:
  - Schema is the source of truth, TypeScript types inferred from it
  - Maintains backwards compatibility - Mode type still exported from article-writer types
  - Type safety ensured - impossible for schema and types to drift apart
  - No runtime behavior changes, purely type system improvement
- Files changed:
  - app/routes/videos.$videoId.completions.ts (extracted modeSchema, exported TextWritingAgentMode type)
  - app/services/text-writing-agent.ts (removed type definition, imported from completions route)
  - app/features/article-writer/types.ts (removed type definition, imported and aliased from completions route)
- Testing:
  - All tests pass (21 passed)
  - TypeScript type checking passes
- Next steps:
  - Issue #86 is complete - single source of truth established for mode types


## Issue #87 - Right-click video to open article page
- Changed video card link destination from edit page to write page
- Implementation details:
  - Updated Link in _index.tsx from `/videos/${videoId}/edit` to `/videos/${videoId}/write`
  - Video card now navigates to article writing page on left-click
  - Right-click on video card shows native browser context menu (Open in new tab, Copy link, etc.)
  - Custom context menu still provides "Edit Video" option for accessing editor
- Key decisions:
  - Changed primary action from "edit" to "write article" (more common workflow)
  - Preserves all existing functionality via context menu
  - Native browser right-click provides expected "Open in new tab" behavior
- Files changed:
  - app/routes/_index.tsx (changed video card Link destination)
- Testing:
  - All tests pass (21 passed)
  - TypeScript type checking passes
- Next steps:
  - Issue #87 is complete - users can now right-click videos to open article page in new tab


## Issue #88 - Add lint system for article writer
- Implemented comprehensive lint system for detecting and fixing style violations in AI output
- Implementation details:
  - Created app/features/article-writer/lint-rules.ts with LintRule and LintViolation interfaces
  - Added LINT_RULES array with initial em-dash rule (pattern: /â€”/g, applies to all modes)
  - Created app/hooks/use-lint.ts hook for real-time violation checking
  - Hook uses useMemo to check violations on every text change (real-time during streaming)
  - Returns violations array and composeFixMessage function
  - Added lint button to article writer toolbar (between Copy and README buttons)
  - Button shows total violation count: "Fix (N)"
  - Button disabled during streaming to prevent interrupting AI mid-response
  - Tooltip shows breakdown of violations by rule name and count
  - handleFixLintViolations sends fix request message to LLM with full context
  - Fix message format: "Please fix the following issues in your response:\n- [instructions]\n\nOutput the corrected version."
  - System designed for easy addition of new rules (just add to LINT_RULES array with mode restrictions)
- Key decisions:
  - Lint checks run in real-time via useMemo for immediate feedback during streaming
  - Button only appears when violations.length > 0 (conditional rendering)
  - Disabled during streaming to prevent accidental interruption
  - Fix request includes all context (files, mode, model, transcript, sections) for consistency
  - Uses AlertTriangleIcon for visual distinction from other toolbar buttons
  - Tooltip uses space-y-1 for clean vertical spacing of multiple violations
  - Em-dash rule applies to all 10 modes (modes: null)
- Files changed:
  - app/features/article-writer/lint-rules.ts (new file - rule definitions)
  - app/hooks/use-lint.ts (new hook - violation checking logic)
  - app/routes/videos.$videoId.write.tsx (integrated lint button and handler)
- Testing:
  - All tests pass (21 passed)
  - TypeScript type checking passes
- Next steps:
  - Issue #88 is complete - lint system fully functional with em-dash detection
  - Future rules can be easily added to LINT_RULES array with appropriate mode restrictions


## Issue #89 - Show lint rule violations in orange
- Changed lint button icon color to orange for better visibility
- Implementation details:
  - Added text-orange-500 class to AlertTriangleIcon in lint Fix button
  - Icon now displays in orange (#f97316 in Tailwind) when violations are detected
  - Makes lint violations more visually prominent in the toolbar
- Key decisions:
  - Used Tailwind's text-orange-500 for consistent color with design system
  - Only changed icon color, button and text remain default for clean UI
- Files changed:
  - app/routes/videos.$videoId.write.tsx (added text-orange-500 class to icon)
- Testing:
  - All tests pass (21 passed)
  - TypeScript type checking passes
- Next steps:
  - Issue #89 is complete - lint violations now highlighted in orange


## Issue #91 - Fix hook rendering error when adding clip section
- Fixed "rendered more hooks than during the previous render" error
- Implementation details:
  - Removed useCallback hooks from inside .map() loop in ClipTimeline component (lines 74-88)
  - useCallback was being called conditionally based on array length, violating Rules of Hooks
  - Changed inline callbacks from useCallback(() => {...}, []) to plain arrow functions () => {...}
  - Removed unused useCallback import from react
  - Functions passed as props already have stable references from useContextSelector in parent
- Key decisions:
  - useCallback with empty deps inside map loop is both incorrect (breaks Rules of Hooks) and unnecessary
  - Parent context already provides stable function references via useContextSelector
  - No performance impact - child components receive same inline functions as before
- Files changed:
  - app/features/video-editor/components/clip-timeline.tsx (removed useCallback from map loop)
- Testing:
  - All tests pass (21 passed)
  - TypeScript type checking passes
- Next steps:
  - Issue #91 is complete - clip sections can now be added without hook rendering errors
