import type { DB } from "@/db/schema";
import type { BeatType } from "@/services/tt-cli-service";
import type { EffectReducer } from "use-effect-reducer";
import type { Brand } from "./utils";

export type DatabaseId = Brand<string, "DatabaseId">;
export type FrontendId = Brand<string, "FrontendId">;
export type FrontendInsertionPoint =
  | {
      type: "start";
    }
  | {
      type: "after-clip";
      frontendClipId: FrontendId;
    }
  | {
      type: "after-clip-section";
      frontendClipSectionId: FrontendId;
    }
  | {
      type: "end";
    };

export type DatabaseInsertionPoint =
  | {
      type: "after-clip";
      databaseClipId: DatabaseId;
    }
  | {
      type: "after-clip-section";
      databaseClipSectionId: DatabaseId;
    }
  | {
      type: "start";
    };

/**
 * A narrower type for insertion points that can be sent to the backend API.
 * The backend currently doesn't understand clip sections, so we only send
 * "start" or "after-clip".
 */
export type ApiInsertionPoint =
  | {
      type: "start";
    }
  | {
      type: "after-clip";
      databaseClipId: DatabaseId;
    };

export type ClipOnDatabase = {
  type: "on-database";
  frontendId: FrontendId;
  databaseId: DatabaseId;
  videoFilename: string;
  sourceStartTime: number; // Start time in source video (seconds)
  sourceEndTime: number; // End time in source video (seconds)
  text: string;
  transcribedAt: Date | null;
  scene: string | null;
  profile: string | null;
  insertionOrder: number | null;
  beatType: BeatType;
};

export type ClipOptimisticallyAdded = {
  type: "optimistically-added";
  frontendId: FrontendId;
  scene: string;
  profile: string;
  /**
   * An integer, incremented each time a new optimistically added clip is added.
   * Used to determine which clips should be paired with which database clips,
   * and to handle the deletion of the latest inserted clip.
   */
  insertionOrder: number;
  /**
   * If true, when the optimistically added clip is replaced with the database clip,
   * the clip will be archived. Allows the user to delete the clip before it's transcribed.
   */
  shouldArchive?: boolean;
  beatType: BeatType;
  /**
   * Unique ID for the sound detection that triggered this clip.
   * Used for deduplication - prevents duplicate clips from React StrictMode double-firing.
   */
  soundDetectionId: string;
};

export const createFrontendId = (): FrontendId => {
  return crypto.randomUUID() as FrontendId;
};

export type Clip = ClipOnDatabase | ClipOptimisticallyAdded;

export type ClipSectionOnDatabase = {
  type: "clip-section-on-database";
  frontendId: FrontendId;
  databaseId: DatabaseId;
  name: string;
  insertionOrder: number | null;
};

export type ClipSectionOptimisticallyAdded = {
  type: "clip-section-optimistically-added";
  frontendId: FrontendId;
  name: string;
  insertionOrder: number;
  shouldArchive?: boolean;
};

export type ClipSection = ClipSectionOnDatabase | ClipSectionOptimisticallyAdded;

export type TimelineItem = Clip | ClipSection;

export namespace clipStateReducer {
  export type State = {
    items: TimelineItem[];
    clipIdsBeingTranscribed: Set<FrontendId>;
    insertionPoint: FrontendInsertionPoint;
    insertionOrder: number;
  };

  export type Action =
    | {
        type: "new-optimistic-clip-detected";
        scene: string;
        profile: string;
        soundDetectionId: string;
      }
    | {
        type: "new-database-clips";
        clips: DB.Clip[];
      }
    | {
        type: "clips-deleted";
        clipIds: FrontendId[];
      }
    | {
        type: "clips-transcribed";
        clips: {
          databaseId: DatabaseId;
          text: string;
        }[];
      }
    | {
        type: "set-insertion-point-after";
        clipId: FrontendId;
      }
    | {
        type: "set-insertion-point-before";
        clipId: FrontendId;
      }
    | {
        type: "delete-latest-inserted-clip";
      }
    | {
        type: "toggle-beat-at-insertion-point";
      }
    | {
        type: "toggle-beat-for-clip";
        clipId: FrontendId;
      }
    | {
        type: "move-clip";
        clipId: FrontendId;
        direction: "up" | "down";
      }
    | {
        type: "add-clip-section";
        name: string;
      };

  export type Effect =
    | {
        type: "transcribe-clips";
        clipIds: DatabaseId[];
      }
    | {
        type: "archive-clips";
        clipIds: DatabaseId[];
      }
    | {
        type: "scroll-to-insertion-point";
      }
    | {
        type: "update-clips";
        clips: [DatabaseId, { scene: string; profile: string; beatType: BeatType }][];
      }
    | {
        type: "update-beat";
        clipId: DatabaseId;
        beatType: BeatType;
      }
    | {
        type: "reorder-clip";
        clipId: DatabaseId;
        direction: "up" | "down";
      }
    | {
        type: "create-clip-section";
        frontendId: FrontendId;
        name: string;
        insertionPoint: FrontendInsertionPoint;
      };
}

export const clipStateReducer: EffectReducer<
  clipStateReducer.State,
  clipStateReducer.Action,
  clipStateReducer.Effect
> = (
  state: clipStateReducer.State,
  action: clipStateReducer.Action,
  exec
): clipStateReducer.State => {
  switch (action.type) {
    case "new-optimistic-clip-detected": {
      // Check if clip with same soundDetectionId already exists (deduplication for React StrictMode)
      const existingClip = state.items.find(
        (c) =>
          c.type === "optimistically-added" &&
          c.soundDetectionId === action.soundDetectionId
      );
      if (existingClip) {
        return state;
      }

      const newFrontendId = createFrontendId();
      const newClip: ClipOptimisticallyAdded = {
        type: "optimistically-added",
        frontendId: newFrontendId,
        scene: action.scene,
        profile: action.profile,
        insertionOrder: state.insertionOrder + 1,
        beatType: "none",
        soundDetectionId: action.soundDetectionId,
      };

      let newInsertionPoint: FrontendInsertionPoint = state.insertionPoint;

      let newClips: TimelineItem[];
      if (state.insertionPoint.type === "end") {
        // Append to end
        newClips = [...state.items, newClip];
      } else if (state.insertionPoint.type === "start") {
        // Insert at start
        newClips = [newClip, ...state.items];
        newInsertionPoint = {
          type: "after-clip",
          frontendClipId: newFrontendId,
        };
      } else if (state.insertionPoint.type === "after-clip") {
        const targetClipId = state.insertionPoint.frontendClipId;
        // Insert at insertion point
        const insertionPointIndex = state.items.findIndex(
          (c) => c.frontendId === targetClipId
        );
        if (insertionPointIndex === -1) {
          throw new Error("Target clip not found when inserting after");
        }
        newClips = [
          ...state.items.slice(0, insertionPointIndex + 1),
          newClip,
          ...state.items.slice(insertionPointIndex + 1),
        ];
        newInsertionPoint = {
          type: "after-clip",
          frontendClipId: newFrontendId,
        };
      } else {
        // after-clip-section
        const targetClipSectionId = state.insertionPoint.frontendClipSectionId;
        // Insert at insertion point
        const insertionPointIndex = state.items.findIndex(
          (c) => c.frontendId === targetClipSectionId
        );
        if (insertionPointIndex === -1) {
          throw new Error("Target clip section not found when inserting after");
        }
        newClips = [
          ...state.items.slice(0, insertionPointIndex + 1),
          newClip,
          ...state.items.slice(insertionPointIndex + 1),
        ];
        newInsertionPoint = {
          type: "after-clip",
          frontendClipId: newFrontendId,
        };
      }

      exec({
        type: "scroll-to-insertion-point",
      });

      return {
        ...state,
        items: newClips,
        insertionOrder: state.insertionOrder + 1,
        insertionPoint: newInsertionPoint,
      };
    }
    case "new-database-clips": {
      let shouldScrollToBottom = false;

      let newClipsState: (TimelineItem | undefined)[] = [...state.items];

      const clipsToArchive = new Set<DatabaseId>();
      const databaseClipIdsToTranscribe = new Set<DatabaseId>();
      const frontendClipIdsToTranscribe = new Set<FrontendId>();
      const clipsToUpdateScene = new Map<
        DatabaseId,
        { scene: string; profile: string; beatType: BeatType }
      >();

      let newInsertionPoint: FrontendInsertionPoint = state.insertionPoint;

      const optimisticClipsSortedByInsertionOrder = newClipsState
        .filter((c) => c?.type === "optimistically-added")
        .sort((a, b) => {
          return a.insertionOrder! - b.insertionOrder!;
        });

      for (const databaseClip of action.clips) {
        const firstOfSortedClips =
          optimisticClipsSortedByInsertionOrder.shift();
        // Find the first optimistically added clip
        const index = newClipsState.findIndex(
          (c) =>
            c?.type === "optimistically-added" &&
            c.insertionOrder === firstOfSortedClips?.insertionOrder
        );

        // If there is a first optimistically added clip, we need to pair it with the database clip
        if (firstOfSortedClips) {
          const frontendClip = newClipsState[index];
          // If the optimistically added clip should be archived, archive the database clip
          if (
            frontendClip?.type === "optimistically-added" &&
            frontendClip?.shouldArchive
          ) {
            clipsToArchive.add(databaseClip.id);
            newClipsState[index] = undefined;
          } else if (frontendClip?.type === "optimistically-added") {
            const newDatabaseClip: ClipOnDatabase = {
              ...databaseClip,
              type: "on-database",
              frontendId: frontendClip.frontendId,
              databaseId: databaseClip.id,
              scene: frontendClip.scene,
              profile: frontendClip.profile,
              insertionOrder: frontendClip.insertionOrder,
              beatType: frontendClip.beatType,
            };
            newClipsState[index] = newDatabaseClip;
            clipsToUpdateScene.set(databaseClip.id, {
              scene: frontendClip.scene,
              profile: frontendClip.profile,
              beatType: frontendClip.beatType,
            });
            frontendClipIdsToTranscribe.add(frontendClip.frontendId);
            databaseClipIdsToTranscribe.add(databaseClip.id);
          }
        } else {
          const newFrontendId = createFrontendId();

          const newDatabaseClip: ClipOnDatabase = {
            type: "on-database",
            ...databaseClip,
            frontendId: newFrontendId,
            databaseId: databaseClip.id,
            insertionOrder: state.insertionOrder + 1,
            beatType: databaseClip.beatType as BeatType,
          };

          const result = insertClip(
            newClipsState,
            newDatabaseClip,
            state.insertionPoint
          );

          newClipsState = result.clips;
          newInsertionPoint = result.insertionPoint;

          frontendClipIdsToTranscribe.add(newFrontendId);
          databaseClipIdsToTranscribe.add(databaseClip.id);

          shouldScrollToBottom = true;
        }
      }

      if (clipsToUpdateScene.size > 0) {
        exec({
          type: "update-clips",
          clips: Array.from(clipsToUpdateScene.entries()),
        });
      }

      if (shouldScrollToBottom) {
        exec({
          type: "scroll-to-insertion-point",
        });
      }

      if (clipsToArchive.size > 0) {
        exec({
          type: "archive-clips",
          clipIds: Array.from(clipsToArchive),
        });
      }

      if (databaseClipIdsToTranscribe.size > 0) {
        exec({
          type: "transcribe-clips",
          clipIds: Array.from(databaseClipIdsToTranscribe),
        });
      }

      return {
        ...state,
        clipIdsBeingTranscribed: new Set([
          ...Array.from(state.clipIdsBeingTranscribed),
          ...Array.from(frontendClipIdsToTranscribe),
        ]),
        items: newClipsState.filter((c) => c !== undefined),
        insertionPoint: newInsertionPoint,
      };
    }
    case "clips-deleted": {
      const { items, clipsToArchive, insertionPoint } = archiveClips(
        state.items,
        action.clipIds,
        state.insertionPoint
      );

      if (clipsToArchive.size > 0) {
        exec({
          type: "archive-clips",
          clipIds: Array.from(clipsToArchive),
        });
      }
      return {
        ...state,
        items,
        insertionPoint: insertionPoint,
      };
    }
    case "clips-transcribed": {
      const set = new Set([...state.clipIdsBeingTranscribed]);

      const textMap: Record<DatabaseId, string> = action.clips.reduce(
        (acc, clip) => {
          acc[clip.databaseId] = clip.text;
          return acc;
        },
        {} as Record<DatabaseId, string>
      );

      return {
        ...state,
        items: state.items.map((item) => {
          if (item.type === "on-database" && textMap[item.databaseId]) {
            set.delete(item.frontendId);
            return { ...item, text: textMap[item.databaseId]! };
          }
          return item;
        }),
        clipIdsBeingTranscribed: set,
      };
    }
    case "set-insertion-point-after": {
      const clip = state.items.find((c) => c.frontendId === action.clipId);
      if (!clip) {
        return state;
      }

      return {
        ...state,
        insertionPoint: {
          type: "after-clip",
          frontendClipId: action.clipId,
        },
      };
    }
    case "set-insertion-point-before": {
      const clip = state.items.find((c) => c.frontendId === action.clipId);
      if (!clip) {
        return state;
      }

      // If inserting before, we need to find the previous clip's frontendId
      // to use as insertAfterId, OR use INSERTION_POINT_START if this is first clip
      const clipIndex = state.items.findIndex(
        (c) => c.frontendId === action.clipId
      );

      let insertionPoint: FrontendInsertionPoint;
      if (clipIndex === 0) {
        // First clip - use magic constant
        insertionPoint = { type: "start" };
      } else {
        // Not first clip - use previous clip's frontendId
        const previousClip = state.items[clipIndex - 1];

        if (previousClip) {
          insertionPoint = {
            type: "after-clip",
            frontendClipId: previousClip.frontendId,
          };
        } else {
          throw new Error("Previous clip not found when inserting before");
        }
      }

      return {
        ...state,
        insertionPoint,
      };
    }
    case "delete-latest-inserted-clip": {
      if (state.insertionPoint.type === "start") {
        return state;
      }

      if (state.insertionPoint.type === "end") {
        const lastClip = state.items[state.items.length - 1];

        if (!lastClip) {
          return state;
        }
        const { items, clipsToArchive, insertionPoint } = archiveClips(
          state.items,
          [lastClip.frontendId],
          state.insertionPoint
        );

        if (clipsToArchive.size > 0) {
          exec({
            type: "archive-clips",
            clipIds: Array.from(clipsToArchive),
          });
        }

        return {
          ...state,
          items,
          insertionPoint,
        };
      }

      const clipIdToArchive =
        state.insertionPoint.type === "after-clip"
          ? state.insertionPoint.frontendClipId
          : state.insertionPoint.frontendClipSectionId;

      const archiveResult = archiveClips(
        state.items,
        [clipIdToArchive],
        state.insertionPoint
      );

      if (archiveResult.clipsToArchive.size > 0) {
        exec({
          type: "archive-clips",
          clipIds: Array.from(archiveResult.clipsToArchive),
        });
      }

      return {
        ...state,
        items: archiveResult.items,
        insertionPoint: archiveResult.insertionPoint,
      };
    }
    case "toggle-beat-at-insertion-point": {
      // Find the clip at the insertion point (similar to delete-latest-inserted-clip)
      let clipToToggle: Clip | undefined;

      if (state.insertionPoint.type === "start") {
        // No clip before start
        return state;
      }

      if (state.insertionPoint.type === "end") {
        const lastItem = state.items[state.items.length - 1];
        if (lastItem && (lastItem.type === "on-database" || lastItem.type === "optimistically-added")) {
          clipToToggle = lastItem;
        }
      } else if (state.insertionPoint.type === "after-clip") {
        const targetFrontendId = state.insertionPoint.frontendClipId;
        const item = state.items.find(
          (c) => c.frontendId === targetFrontendId
        );
        if (item && (item.type === "on-database" || item.type === "optimistically-added")) {
          clipToToggle = item;
        }
      } else if (state.insertionPoint.type === "after-clip-section") {
        // Don't toggle beat for clip sections
        return state;
      }

      if (!clipToToggle) {
        return state;
      }

      const newBeatType: BeatType =
        clipToToggle.beatType === "none" ? "long" : "none";

      // If it's a database clip, fire an effect to update the DB
      if (clipToToggle.type === "on-database") {
        exec({
          type: "update-beat",
          clipId: clipToToggle.databaseId,
          beatType: newBeatType,
        });
      }

      return {
        ...state,
        items: state.items.map((item) =>
          item.frontendId === clipToToggle!.frontendId && (item.type === "on-database" || item.type === "optimistically-added")
            ? { ...item, beatType: newBeatType }
            : item
        ),
      };
    }
    case "toggle-beat-for-clip": {
      const item = state.items.find(
        (c) => c.frontendId === action.clipId
      );

      if (!item || (item.type !== "on-database" && item.type !== "optimistically-added")) {
        return state;
      }

      const clipToToggle = item;
      const newBeatType: BeatType =
        clipToToggle.beatType === "none" ? "long" : "none";

      // If it's a database clip, fire an effect to update the DB
      if (clipToToggle.type === "on-database") {
        exec({
          type: "update-beat",
          clipId: clipToToggle.databaseId,
          beatType: newBeatType,
        });
      }

      return {
        ...state,
        items: state.items.map((item) =>
          item.frontendId === action.clipId && (item.type === "on-database" || item.type === "optimistically-added")
            ? { ...item, beatType: newBeatType }
            : item
        ),
      };
    }
    case "move-clip": {
      const clipIndex = state.items.findIndex(
        (c) => c.frontendId === action.clipId
      );

      if (clipIndex === -1) {
        return state;
      }

      const clip = state.items[clipIndex]!;
      const targetIndex =
        action.direction === "up" ? clipIndex - 1 : clipIndex + 1;

      // Check boundaries
      if (targetIndex < 0 || targetIndex >= state.items.length) {
        return state;
      }

      // Swap clips in the array
      const newClips = [...state.items];
      newClips[clipIndex] = newClips[targetIndex]!;
      newClips[targetIndex] = clip;

      // Fire effect to update database if this is a database clip
      if (clip.type === "on-database") {
        exec({
          type: "reorder-clip",
          clipId: clip.databaseId,
          direction: action.direction,
        });
      }

      return {
        ...state,
        items: newClips,
      };
    }
    case "add-clip-section": {
      const newFrontendId = createFrontendId();
      const newClipSection: ClipSectionOptimisticallyAdded = {
        type: "clip-section-optimistically-added",
        frontendId: newFrontendId,
        name: action.name,
        insertionOrder: state.insertionOrder + 1,
      };

      let newInsertionPoint: FrontendInsertionPoint = {
        type: "after-clip-section",
        frontendClipSectionId: newFrontendId,
      };

      let newItems: TimelineItem[];
      if (state.insertionPoint.type === "end") {
        // Append to end
        newItems = [...state.items, newClipSection];
      } else if (state.insertionPoint.type === "start") {
        // Insert at start
        newItems = [newClipSection, ...state.items];
      } else if (state.insertionPoint.type === "after-clip") {
        const targetClipId = state.insertionPoint.frontendClipId;
        const insertionPointIndex = state.items.findIndex(
          (c) => c.frontendId === targetClipId
        );
        if (insertionPointIndex === -1) {
          throw new Error("Target clip not found when inserting clip section after");
        }
        newItems = [
          ...state.items.slice(0, insertionPointIndex + 1),
          newClipSection,
          ...state.items.slice(insertionPointIndex + 1),
        ];
      } else {
        // after-clip-section
        const targetClipSectionId = state.insertionPoint.frontendClipSectionId;
        const insertionPointIndex = state.items.findIndex(
          (c) => c.frontendId === targetClipSectionId
        );
        if (insertionPointIndex === -1) {
          throw new Error("Target clip section not found when inserting clip section after");
        }
        newItems = [
          ...state.items.slice(0, insertionPointIndex + 1),
          newClipSection,
          ...state.items.slice(insertionPointIndex + 1),
        ];
      }

      exec({
        type: "create-clip-section",
        frontendId: newFrontendId,
        name: action.name,
        insertionPoint: state.insertionPoint,
      });

      exec({
        type: "scroll-to-insertion-point",
      });

      return {
        ...state,
        items: newItems,
        insertionOrder: state.insertionOrder + 1,
        insertionPoint: newInsertionPoint,
      };
    }
  }
  return state;
};

const insertClip = (
  items: (TimelineItem | undefined)[],
  newClip: Clip,
  insertionPoint: FrontendInsertionPoint
) => {
  let newInsertionPoint: FrontendInsertionPoint = insertionPoint;

  let newItems: (TimelineItem | undefined)[];
  if (insertionPoint.type === "end") {
    // Append to end
    newItems = [...items, newClip];
  } else if (insertionPoint.type === "start") {
    // Insert at start
    newItems = [newClip, ...items];
    newInsertionPoint = {
      type: "after-clip",
      frontendClipId: newClip.frontendId,
    };
  } else if (insertionPoint.type === "after-clip") {
    const targetClipId = insertionPoint.frontendClipId;
    // Insert at insertion point
    const insertionPointIndex = items.findIndex(
      (c) => c?.frontendId === targetClipId
    );
    if (insertionPointIndex === -1) {
      throw new Error("Target clip not found when inserting after");
    }
    newItems = [
      ...items.slice(0, insertionPointIndex + 1),
      newClip,
      ...items.slice(insertionPointIndex + 1),
    ];
    newInsertionPoint = {
      type: "after-clip",
      frontendClipId: targetClipId,
    };
  } else if (insertionPoint.type === "after-clip-section") {
    const targetClipSectionId = insertionPoint.frontendClipSectionId;
    // Insert at insertion point
    const insertionPointIndex = items.findIndex(
      (c) => c?.frontendId === targetClipSectionId
    );
    if (insertionPointIndex === -1) {
      throw new Error("Target clip section not found when inserting after");
    }
    newItems = [
      ...items.slice(0, insertionPointIndex + 1),
      newClip,
      ...items.slice(insertionPointIndex + 1),
    ];
    newInsertionPoint = {
      type: "after-clip",
      frontendClipId: newClip.frontendId,
    };
  } else {
    throw new Error("Unknown insertion point type");
  }

  return {
    clips: newItems,
    insertionPoint: newInsertionPoint,
  };
};

type ArchiveClipMode =
  | {
      type: "move-insertion-point-to-previous-clip";
      originalClipIndex: number;
    }
  | {
      type: "do-nothing";
    };

const archiveClips = (
  allItems: TimelineItem[],
  frontendIds: FrontendId[],
  insertionPoint: FrontendInsertionPoint
): {
  items: TimelineItem[];
  insertionPoint: FrontendInsertionPoint;
  clipsToArchive: Set<DatabaseId>;
} => {
  const clipsToArchive = new Set<DatabaseId>();

  let archiveClipMode: ArchiveClipMode;

  if (
    insertionPoint.type === "after-clip" &&
    frontendIds.includes(insertionPoint.frontendClipId)
  ) {
    const clipId = insertionPoint.frontendClipId;
    const prevClipIndex = allItems.findIndex((c) => c.frontendId === clipId);
    if (prevClipIndex === -1) {
      throw new Error("Previous clip not found when archiving");
    }
    archiveClipMode = {
      type: "move-insertion-point-to-previous-clip",
      originalClipIndex: prevClipIndex,
    };
  } else {
    archiveClipMode = {
      type: "do-nothing",
    };
  }

  const items: (TimelineItem | undefined)[] = [...allItems];
  for (const clipId of frontendIds) {
    const index = items.findIndex((c) => c?.frontendId === clipId);
    if (index === -1) continue;

    const itemToReplace = items[index]!;
    if (itemToReplace.type === "optimistically-added") {
      itemToReplace.shouldArchive = true;
    } else if (itemToReplace.type === "on-database") {
      clipsToArchive.add(itemToReplace.databaseId);
      items[index] = undefined;
    } else if (itemToReplace.type === "clip-section-optimistically-added") {
      itemToReplace.shouldArchive = true;
    } else if (itemToReplace.type === "clip-section-on-database") {
      // TODO: Archive clip sections via separate endpoint
      items[index] = undefined;
    }
  }

  // If the insertion point is after a clip, and that clip has been deleted,
  // we need to find a candidate for the insertion point
  if (archiveClipMode.type === "move-insertion-point-to-previous-clip") {
    const slicedItems = items.slice(0, archiveClipMode.originalClipIndex);

    const previousNonUndefinedItem = slicedItems.findLast(
      (c) => c !== undefined
    );

    let newInsertionPoint: FrontendInsertionPoint;

    if (previousNonUndefinedItem) {
      if (previousNonUndefinedItem.type === "on-database" || previousNonUndefinedItem.type === "optimistically-added") {
        newInsertionPoint = {
          type: "after-clip",
          frontendClipId: previousNonUndefinedItem.frontendId,
        };
      } else {
        newInsertionPoint = {
          type: "after-clip-section",
          frontendClipSectionId: previousNonUndefinedItem.frontendId,
        };
      }
    } else {
      newInsertionPoint = {
        type: "end",
      };
    }

    return {
      items: items.filter((c) => c !== undefined),
      insertionPoint: newInsertionPoint,
      clipsToArchive,
    };
  }

  return {
    items: items.filter((c) => c !== undefined),
    insertionPoint: insertionPoint,
    clipsToArchive: clipsToArchive,
  };
};
